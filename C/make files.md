- A Makefile (sentence cased), also called a descriptor file, is a file containing instructions for the [[Bash commands|terminal]].
- `make` is a program that reads instructions from a Makefile (by default).
- We need a file called Makefile to tell `make` what to do.
- Most often, a Makefile is implemented to tell `make` how to compile and link a program.
- The `make` utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them.
- A Makefile contains:
	- Rules
	- Macros
	- Suffix (or implicit rules)
- Makefiles **must** be indented using TAB characters.

Example

![](https://i.imgur.com/RAtNL2I.png)

# make rules

A simple Makefile consists of rules with the following syntax:

```Bash
<target> : <prerequisites>
	<recipe>
```
Note: Every `<recipe>` must begin with a TAB character.

- A `<target>` is usually the name of a file that is generated by a program; examples of targets are executable or object files.
	- A target can also be the name of an action to carry out, such as `clean`.
- A `<prerequisite>` is a file that is used as input to create the target.
	- A target often depends on several files.
- A `<recipe>` is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line.



We have at least three files that contain:
1. Declaration of function(s) ([[header files]])
2. Definition of function(s) ([[functions]])
3. Source code (main file that contains the program)

A rule explains how and when to remake certain files which are the targets of the particular rule. `make` carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action.

To [[compilation]] we usually compile the definition of the function then compile the actual program.  But if we had many files it'd take long time (and we don't want to do that every time we made some changes to either file); so, we use `Makefile`. 

A Makefile consists of a set of _rules_. A rule generally looks like this:

```
targets: dependencies
	command // Tab indentation matters
	command // Tab indentation matters
	command // Tab indentation matters
```

-   The _targets_ are file names, separated by spaces. Typically, there is only one per rule.
-   The _commands_ are a series of steps typically used to make the target(s). These _need to start with a tab character_, not spaces.
-   The _dependencies_ are also file names, separated by spaces. These files need to exist before the commands for the target are run.

```
blah:
	cc blah.c -o blah
```

This time, try simply running `make`. Since there's no target supplied as an argument to the `make` command, the first target is run. In this case, there's only one target (`blah`). The first time you run this, `blah` will be created. The second time, you'll see `make: 'blah' is up to date`. That's because the `blah` file already exists. But there's a problem: if we modify `blah.c` and then run `make`, nothing gets recompiled.

We solve this by adding a prerequisite:

```
blah: blah.c
	cc blah.c -o blah
```

When we run `make` again, the following set of steps happens:

-   The first target is selected, because the first target is the default target
-   This has a prerequisite of `blah.c`
-   Make decides if it should run the `blah` target. It will only run if `blah` doesn't exist, or `blah.c` is _newer than_ `blah`

# options

`make -f file`: Read the file named file as a makefile (default name should be Make).

[Make options](https://www.gnu.org/software/make/manual/html_node/Options-Summary.html)

[A Simple Makefile Tutorial](https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)